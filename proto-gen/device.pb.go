// Code generated by protoc-gen-go. DO NOT EDIT.
// source: device.proto

package libhuestacean

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Describes a type of light provider known by the daemon
type DeviceProviderArchetype struct {
	// Archetype's name, e.g. "Philips Hue bridge"
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Whether the provider supports low latency light updates
	LowLatencySupported bool `protobuf:"varint,2,opt,name=low_latency_supported,json=lowLatencySupported,proto3" json:"low_latency_supported,omitempty"`
	// if > 0, how many low-latency lights can be present at once; if <= 0, no limit
	MaxLowLatency        uint32   `protobuf:"varint,3,opt,name=max_low_latency,json=maxLowLatency,proto3" json:"max_low_latency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceProviderArchetype) Reset()         { *m = DeviceProviderArchetype{} }
func (m *DeviceProviderArchetype) String() string { return proto.CompactTextString(m) }
func (*DeviceProviderArchetype) ProtoMessage()    {}
func (*DeviceProviderArchetype) Descriptor() ([]byte, []int) {
	return fileDescriptor_device_d3ed2cb450c6073a, []int{0}
}
func (m *DeviceProviderArchetype) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeviceProviderArchetype.Unmarshal(m, b)
}
func (m *DeviceProviderArchetype) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeviceProviderArchetype.Marshal(b, m, deterministic)
}
func (dst *DeviceProviderArchetype) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceProviderArchetype.Merge(dst, src)
}
func (m *DeviceProviderArchetype) XXX_Size() int {
	return xxx_messageInfo_DeviceProviderArchetype.Size(m)
}
func (m *DeviceProviderArchetype) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceProviderArchetype.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceProviderArchetype proto.InternalMessageInfo

func (m *DeviceProviderArchetype) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *DeviceProviderArchetype) GetLowLatencySupported() bool {
	if m != nil {
		return m.LowLatencySupported
	}
	return false
}

func (m *DeviceProviderArchetype) GetMaxLowLatency() uint32 {
	if m != nil {
		return m.MaxLowLatency
	}
	return 0
}

// A light contained within a device archetype, with its default location
type DeviceArchetypeLight struct {
	DefaultLocation      *LightLocation `protobuf:"bytes,1,opt,name=default_location,json=defaultLocation,proto3" json:"default_location,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *DeviceArchetypeLight) Reset()         { *m = DeviceArchetypeLight{} }
func (m *DeviceArchetypeLight) String() string { return proto.CompactTextString(m) }
func (*DeviceArchetypeLight) ProtoMessage()    {}
func (*DeviceArchetypeLight) Descriptor() ([]byte, []int) {
	return fileDescriptor_device_d3ed2cb450c6073a, []int{1}
}
func (m *DeviceArchetypeLight) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeviceArchetypeLight.Unmarshal(m, b)
}
func (m *DeviceArchetypeLight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeviceArchetypeLight.Marshal(b, m, deterministic)
}
func (dst *DeviceArchetypeLight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceArchetypeLight.Merge(dst, src)
}
func (m *DeviceArchetypeLight) XXX_Size() int {
	return xxx_messageInfo_DeviceArchetypeLight.Size(m)
}
func (m *DeviceArchetypeLight) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceArchetypeLight.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceArchetypeLight proto.InternalMessageInfo

func (m *DeviceArchetypeLight) GetDefaultLocation() *LightLocation {
	if m != nil {
		return m.DefaultLocation
	}
	return nil
}

// Describes a type of device known by the daemon
type DeviceArchetype struct {
	// Whether the lights contained within can be moved (if not, only the whole device can be moved)
	AreLightsMovable bool `protobuf:"varint,1,opt,name=are_lights_movable,json=areLightsMovable,proto3" json:"are_lights_movable,omitempty"`
	// This device's lights, with their default location.
	// the key, an int, is unique only _within_ this device; e.g. two Devices may have the same Light0
	Lights               map[uint32]*DeviceArchetypeLight `protobuf:"bytes,2,rep,name=lights,proto3" json:"lights,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *DeviceArchetype) Reset()         { *m = DeviceArchetype{} }
func (m *DeviceArchetype) String() string { return proto.CompactTextString(m) }
func (*DeviceArchetype) ProtoMessage()    {}
func (*DeviceArchetype) Descriptor() ([]byte, []int) {
	return fileDescriptor_device_d3ed2cb450c6073a, []int{2}
}
func (m *DeviceArchetype) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeviceArchetype.Unmarshal(m, b)
}
func (m *DeviceArchetype) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeviceArchetype.Marshal(b, m, deterministic)
}
func (dst *DeviceArchetype) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceArchetype.Merge(dst, src)
}
func (m *DeviceArchetype) XXX_Size() int {
	return xxx_messageInfo_DeviceArchetype.Size(m)
}
func (m *DeviceArchetype) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceArchetype.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceArchetype proto.InternalMessageInfo

func (m *DeviceArchetype) GetAreLightsMovable() bool {
	if m != nil {
		return m.AreLightsMovable
	}
	return false
}

func (m *DeviceArchetype) GetLights() map[uint32]*DeviceArchetypeLight {
	if m != nil {
		return m.Lights
	}
	return nil
}

// DeviceProvider is a service the daemon is using to connect to lights,
// e.g. it may be a single Hue bridge, or it may be the Razer Chroma SDK
type DeviceProvider struct {
	// What sort of light provider is this? This is the underlying tech / API being used.
	ArchetypeId uint32 `protobuf:"varint,1,opt,name=archetype_id,json=archetypeId,proto3" json:"archetype_id,omitempty"`
	// Name of the light provider. Disambiguates between providers of the same archetype.
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceProvider) Reset()         { *m = DeviceProvider{} }
func (m *DeviceProvider) String() string { return proto.CompactTextString(m) }
func (*DeviceProvider) ProtoMessage()    {}
func (*DeviceProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_device_d3ed2cb450c6073a, []int{3}
}
func (m *DeviceProvider) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeviceProvider.Unmarshal(m, b)
}
func (m *DeviceProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeviceProvider.Marshal(b, m, deterministic)
}
func (dst *DeviceProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceProvider.Merge(dst, src)
}
func (m *DeviceProvider) XXX_Size() int {
	return xxx_messageInfo_DeviceProvider.Size(m)
}
func (m *DeviceProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceProvider.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceProvider proto.InternalMessageInfo

func (m *DeviceProvider) GetArchetypeId() uint32 {
	if m != nil {
		return m.ArchetypeId
	}
	return 0
}

func (m *DeviceProvider) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Devices are a thing in the real-world that emit light, and that Huestacean can control.
type Device struct {
	// What sort of light is this? This is the underlying tech / API being used.
	ArchetypeId uint32 `protobuf:"varint,1,opt,name=archetype_id,json=archetypeId,proto3" json:"archetype_id,omitempty"`
	// The device's friendly name, if it has one
	Name                 uint32   `protobuf:"varint,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Device) Reset()         { *m = Device{} }
func (m *Device) String() string { return proto.CompactTextString(m) }
func (*Device) ProtoMessage()    {}
func (*Device) Descriptor() ([]byte, []int) {
	return fileDescriptor_device_d3ed2cb450c6073a, []int{4}
}
func (m *Device) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Device.Unmarshal(m, b)
}
func (m *Device) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Device.Marshal(b, m, deterministic)
}
func (dst *Device) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Device.Merge(dst, src)
}
func (m *Device) XXX_Size() int {
	return xxx_messageInfo_Device.Size(m)
}
func (m *Device) XXX_DiscardUnknown() {
	xxx_messageInfo_Device.DiscardUnknown(m)
}

var xxx_messageInfo_Device proto.InternalMessageInfo

func (m *Device) GetArchetypeId() uint32 {
	if m != nil {
		return m.ArchetypeId
	}
	return 0
}

func (m *Device) GetName() uint32 {
	if m != nil {
		return m.Name
	}
	return 0
}

// The position of a light in the room is given as an axis-aligned box.
// This position is given as relative to its device.
type LightLocation struct {
	MinX                 float32  `protobuf:"fixed32,1,opt,name=min_x,json=minX,proto3" json:"min_x,omitempty"`
	MinY                 float32  `protobuf:"fixed32,2,opt,name=min_y,json=minY,proto3" json:"min_y,omitempty"`
	MinZ                 float32  `protobuf:"fixed32,3,opt,name=min_z,json=minZ,proto3" json:"min_z,omitempty"`
	MaxX                 float32  `protobuf:"fixed32,4,opt,name=max_x,json=maxX,proto3" json:"max_x,omitempty"`
	MaxY                 float32  `protobuf:"fixed32,5,opt,name=max_y,json=maxY,proto3" json:"max_y,omitempty"`
	MaxZ                 float32  `protobuf:"fixed32,6,opt,name=max_z,json=maxZ,proto3" json:"max_z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LightLocation) Reset()         { *m = LightLocation{} }
func (m *LightLocation) String() string { return proto.CompactTextString(m) }
func (*LightLocation) ProtoMessage()    {}
func (*LightLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_device_d3ed2cb450c6073a, []int{5}
}
func (m *LightLocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LightLocation.Unmarshal(m, b)
}
func (m *LightLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LightLocation.Marshal(b, m, deterministic)
}
func (dst *LightLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LightLocation.Merge(dst, src)
}
func (m *LightLocation) XXX_Size() int {
	return xxx_messageInfo_LightLocation.Size(m)
}
func (m *LightLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_LightLocation.DiscardUnknown(m)
}

var xxx_messageInfo_LightLocation proto.InternalMessageInfo

func (m *LightLocation) GetMinX() float32 {
	if m != nil {
		return m.MinX
	}
	return 0
}

func (m *LightLocation) GetMinY() float32 {
	if m != nil {
		return m.MinY
	}
	return 0
}

func (m *LightLocation) GetMinZ() float32 {
	if m != nil {
		return m.MinZ
	}
	return 0
}

func (m *LightLocation) GetMaxX() float32 {
	if m != nil {
		return m.MaxX
	}
	return 0
}

func (m *LightLocation) GetMaxY() float32 {
	if m != nil {
		return m.MaxY
	}
	return 0
}

func (m *LightLocation) GetMaxZ() float32 {
	if m != nil {
		return m.MaxZ
	}
	return 0
}

// Devices do not emit light, their coordinates are given as a (3D) point
// and scaling factor that's applied uniformly to the contained lights
type DeviceLocation struct {
	X                    float32  `protobuf:"fixed32,1,opt,name=x,proto3" json:"x,omitempty"`
	Y                    float32  `protobuf:"fixed32,2,opt,name=y,proto3" json:"y,omitempty"`
	Z                    float32  `protobuf:"fixed32,3,opt,name=z,proto3" json:"z,omitempty"`
	ScaleX               float32  `protobuf:"fixed32,4,opt,name=scale_x,json=scaleX,proto3" json:"scale_x,omitempty"`
	ScaleY               float32  `protobuf:"fixed32,5,opt,name=scale_y,json=scaleY,proto3" json:"scale_y,omitempty"`
	ScaleZ               float32  `protobuf:"fixed32,6,opt,name=scale_z,json=scaleZ,proto3" json:"scale_z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeviceLocation) Reset()         { *m = DeviceLocation{} }
func (m *DeviceLocation) String() string { return proto.CompactTextString(m) }
func (*DeviceLocation) ProtoMessage()    {}
func (*DeviceLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_device_d3ed2cb450c6073a, []int{6}
}
func (m *DeviceLocation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeviceLocation.Unmarshal(m, b)
}
func (m *DeviceLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeviceLocation.Marshal(b, m, deterministic)
}
func (dst *DeviceLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceLocation.Merge(dst, src)
}
func (m *DeviceLocation) XXX_Size() int {
	return xxx_messageInfo_DeviceLocation.Size(m)
}
func (m *DeviceLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceLocation.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceLocation proto.InternalMessageInfo

func (m *DeviceLocation) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *DeviceLocation) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *DeviceLocation) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *DeviceLocation) GetScaleX() float32 {
	if m != nil {
		return m.ScaleX
	}
	return 0
}

func (m *DeviceLocation) GetScaleY() float32 {
	if m != nil {
		return m.ScaleY
	}
	return 0
}

func (m *DeviceLocation) GetScaleZ() float32 {
	if m != nil {
		return m.ScaleZ
	}
	return 0
}

func init() {
	proto.RegisterType((*DeviceProviderArchetype)(nil), "libhuestacean.DeviceProviderArchetype")
	proto.RegisterType((*DeviceArchetypeLight)(nil), "libhuestacean.DeviceArchetypeLight")
	proto.RegisterType((*DeviceArchetype)(nil), "libhuestacean.DeviceArchetype")
	proto.RegisterMapType((map[uint32]*DeviceArchetypeLight)(nil), "libhuestacean.DeviceArchetype.LightsEntry")
	proto.RegisterType((*DeviceProvider)(nil), "libhuestacean.DeviceProvider")
	proto.RegisterType((*Device)(nil), "libhuestacean.Device")
	proto.RegisterType((*LightLocation)(nil), "libhuestacean.LightLocation")
	proto.RegisterType((*DeviceLocation)(nil), "libhuestacean.DeviceLocation")
}

func init() { proto.RegisterFile("device.proto", fileDescriptor_device_d3ed2cb450c6073a) }

var fileDescriptor_device_d3ed2cb450c6073a = []byte{
	// 467 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xb1, 0x8f, 0xd3, 0x30,
	0x14, 0xc6, 0xe5, 0xb4, 0x0d, 0xc7, 0x4b, 0x43, 0x2b, 0x1f, 0xe8, 0x22, 0xc4, 0x50, 0x82, 0x84,
	0x2a, 0x84, 0x3a, 0x94, 0x05, 0x58, 0x10, 0x08, 0x74, 0x42, 0x2a, 0x12, 0x32, 0x4b, 0xdb, 0x01,
	0xcb, 0x4d, 0x0c, 0x8d, 0x70, 0xe2, 0x2a, 0x71, 0x7b, 0x49, 0x77, 0x06, 0x06, 0xfe, 0x4a, 0xfe,
	0x11, 0x54, 0x3b, 0x76, 0xaf, 0x1d, 0x90, 0xd8, 0xe2, 0xdf, 0xf7, 0xbe, 0xf7, 0x3e, 0xfb, 0xb5,
	0xd0, 0x4f, 0xf9, 0x2e, 0x4b, 0xf8, 0x64, 0x53, 0x4a, 0x25, 0x71, 0x28, 0xb2, 0xd5, 0x7a, 0xcb,
	0x2b, 0xc5, 0x12, 0xce, 0x8a, 0xf8, 0x17, 0x82, 0xab, 0xf7, 0x5a, 0xff, 0x5c, 0xca, 0x5d, 0x96,
	0xf2, 0xf2, 0x6d, 0x99, 0xac, 0xb9, 0x6a, 0x36, 0x1c, 0x63, 0xe8, 0x16, 0x2c, 0xe7, 0x11, 0x1a,
	0xa1, 0xf1, 0x5d, 0xa2, 0xbf, 0xf1, 0x14, 0x1e, 0x08, 0x79, 0x43, 0x05, 0x53, 0xbc, 0x48, 0x1a,
	0x5a, 0x6d, 0x37, 0x1b, 0x59, 0x2a, 0x9e, 0x46, 0xde, 0x08, 0x8d, 0x2f, 0xc8, 0xa5, 0x90, 0x37,
	0x33, 0xa3, 0x7d, 0xb1, 0x12, 0x7e, 0x0a, 0x83, 0x9c, 0xd5, 0xf4, 0x96, 0x2f, 0xea, 0x8c, 0xd0,
	0x38, 0x24, 0x61, 0xce, 0xea, 0x99, 0x33, 0xc4, 0x14, 0xee, 0x9b, 0x28, 0x2e, 0xc2, 0x2c, 0xfb,
	0xbe, 0x56, 0xf8, 0x1a, 0x86, 0x29, 0xff, 0xc6, 0xb6, 0x42, 0x51, 0x21, 0x13, 0xa6, 0x32, 0x59,
	0xe8, 0x4c, 0xc1, 0xf4, 0xd1, 0xe4, 0xe4, 0x36, 0x13, 0x5d, 0x3f, 0x6b, 0x6b, 0xc8, 0xa0, 0x75,
	0x59, 0x10, 0xff, 0x41, 0x30, 0x38, 0x9b, 0x80, 0x9f, 0x03, 0x66, 0x25, 0xa7, 0xe2, 0xe0, 0xac,
	0x68, 0x2e, 0x77, 0x6c, 0x25, 0xcc, 0x95, 0x2f, 0xc8, 0x90, 0x95, 0x26, 0x42, 0xf5, 0xc9, 0x70,
	0xfc, 0x0e, 0x7c, 0x53, 0x19, 0x79, 0xa3, 0xce, 0x38, 0x98, 0x3e, 0x3b, 0x0b, 0x70, 0xd6, 0xdd,
	0x04, 0xaa, 0x3e, 0x14, 0xaa, 0x6c, 0x48, 0xeb, 0x7c, 0xf8, 0x15, 0x82, 0x5b, 0x18, 0x0f, 0xa1,
	0xf3, 0x83, 0x37, 0x7a, 0x62, 0x48, 0x0e, 0x9f, 0xf8, 0x15, 0xf4, 0x76, 0x4c, 0x6c, 0xb9, 0x7e,
	0xd3, 0x60, 0xfa, 0xe4, 0xdf, 0x33, 0x74, 0x2f, 0x62, 0x1c, 0xaf, 0xbd, 0x97, 0x28, 0xbe, 0x86,
	0x7b, 0xa7, 0x1b, 0xc5, 0x8f, 0xa1, 0xcf, 0x6c, 0x39, 0xcd, 0xd2, 0x76, 0x56, 0xe0, 0xd8, 0xc7,
	0xd4, 0xed, 0xda, 0x3b, 0xee, 0x3a, 0x7e, 0x03, 0xbe, 0x69, 0xf4, 0xbf, 0x0d, 0xc2, 0xb6, 0xc1,
	0x6f, 0x04, 0xe1, 0xc9, 0x4a, 0xf0, 0x25, 0xf4, 0xf2, 0xac, 0xa0, 0xb5, 0xee, 0xe0, 0x91, 0x6e,
	0x9e, 0x15, 0x73, 0x0b, 0x1b, 0xed, 0x35, 0x70, 0x61, 0xe1, 0x5e, 0xff, 0x54, 0x0c, 0x5c, 0x6a,
	0xc8, 0x6a, 0x5a, 0x47, 0xdd, 0x16, 0xb2, 0x7a, 0x6e, 0x61, 0x13, 0xf5, 0x1c, 0x5c, 0x58, 0xb8,
	0x8f, 0x7c, 0x07, 0x97, 0xf1, 0x4f, 0x64, 0x9f, 0xc6, 0x05, 0xea, 0x03, 0xb2, 0x61, 0x50, 0x7d,
	0x38, 0xd9, 0x14, 0xa8, 0x39, 0x9c, 0xec, 0x78, 0xb4, 0xc7, 0x57, 0x70, 0xa7, 0x4a, 0x98, 0xe0,
	0x6e, 0xba, 0xaf, 0x8f, 0xf3, 0xa3, 0x60, 0x13, 0x18, 0x61, 0x71, 0x14, 0x6c, 0x0a, 0x23, 0x2c,
	0x57, 0xbe, 0xfe, 0x2b, 0xbe, 0xf8, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x2c, 0x33, 0x74, 0x3a, 0x9a,
	0x03, 0x00, 0x00,
}
